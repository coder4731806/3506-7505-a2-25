package uq.comp3506.a2.structures;

import java.util.Objects;

/**
 * Supplied by the COMP3506/7505 teaching team, Semester 2, 2025.
 * An abstract view of an Edge in an undirected graph.
 * `S` is the type of the data payload of the vertices the edges connect.
 * `U` is the type of the data payload of an edge.
 * We use `S` and `U` to avoid confusion between V and E in typical graph
 * nomenclature.
 */
public class Edge<S, U> {
    /** The first of the two vertices this edge connects. */
    private Vertex<S> vertex1;
    
    /** The second of the two vertices this edge connects. */
    private Vertex<S> vertex2;
    
    /** The data stored at this edge. */
    private U data;

    /**
     * Constructs a new Edge for an undirected graph.
     * The order of the vertices does not matter.
     *
     * @param vertex1 The first vertex of the edge.
     * @param vertex2 The second vertex of the edge.
     * @param data The data payload for the edge.
     */
    public Edge(Vertex<S> vertex1, Vertex<S> vertex2, U data) {
        this.vertex1 = vertex1;
        this.vertex2 = vertex2;
        this.data = data;
    }

    /** Getter for v1. */
    public Vertex<S> getVertex1() {
        return vertex1;
    }

    /** Getter for v2. */
    public Vertex<S> getVertex2() {
        return vertex2;
    }

    /** Getter for data payload. */
    public U getData() {
        return data;
    }
    
    // You may or may not need these setters.

    /** Setter for v1. */
    public void setVertex1(Vertex<S> vertex1) {
        this.vertex1 = vertex1;
    }

    /** Setter for v2. */
    public void setVertex2(Vertex<S> vertex2) {
        this.vertex2 = vertex2;
    }

    /** Setter for data. */
    public void setData(U data) {
        this.data = data;
    }

    /** Autogenerated - computes a hash for an Edge type*/
    @Override
    public int hashCode() {
        // Ensure the hash code is the same for (v1, v2) and (v2, v1)
        // by using a commutative operation on the vertex hashes.
        // We also need to include the data's hash code.
        int vertexHash = vertex1.hashCode() ^ vertex2.hashCode();
        return Objects.hash(vertexHash, data);
    }
  
    /** Autogenerated - computes equality of edges*/
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        
        Edge<?, ?> other = (Edge<?, ?>) obj;
        
        // Check if the data is equal (null-safe)
        boolean dataEquals = Objects.equals(this.data, other.data);

        // Check for both permutations of vertices, since the graph is undirected
        boolean verticesEqual = (Objects.equals(this.vertex1, other.vertex1)
                         && Objects.equals(this.vertex2, other.vertex2))
                        || (Objects.equals(this.vertex1, other.vertex2)
                            && Objects.equals(this.vertex2, other.vertex1));

        return dataEquals && verticesEqual;
    }

}
